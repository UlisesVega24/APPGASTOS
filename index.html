<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Control de Gastos</title>

  <style>
    :root{
      --bg:#0f172a; --panel:#111827; --text:#111827; --muted:#9ca3af; --accent:#34d399;
      --white:#ffffff; --shadow:rgba(0,0,0,.25);
    }
    *{box-sizing:border-box}
    body{margin:0;background:linear-gradient(180deg,var(--bg),#0b1220);color:var(--text);font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,Helvetica Neue,Arial,Noto Sans,sans-serif;line-height:1.55}
    .container{max-width:1100px;margin:0 auto;padding:24px}
    header{display:flex;align-items:center;justify-content:space-between;margin-bottom:16px}
    h1{font-size:1.25rem;margin:0;color:var(--accent);letter-spacing:.2px}
    .nav{display:flex;gap:8px;position:sticky;top:8px;padding:8px;background:#fff;border-radius:999px;box-shadow:0 8px 24px var(--shadow);z-index:10}
    .btn{padding:8px 14px;border:0;border-radius:999px;font-weight:600;cursor:pointer;transition:.2s}
    .btn--muted{background:#f3f4f6;color:#111827}
    .btn--accent{background:#10b981;color:#fff}
    .btn--danger{background:#ef4444;color:#fff}
    .btn--primary{background:#3b82f6;color:#fff}
    .btn--yellow{background:#f59e0b;color:#fff}
    .btn--ghost{background: #EF4444;color:#111827}
    .btn:disabled{opacity:.6;cursor:not-allowed}
    .panel{background:var(--panel);border:1px solid rgba(255,255,255,.06);border-radius:14px;padding:16px;box-shadow:0 10px 25px rgba(0,0,0,.35);overflow:auto}
    .grid{display:grid;gap:16px}
    .grid--3{grid-template-columns:repeat(3,minmax(0,1fr))}
    @media (max-width:900px){.grid--3{grid-template-columns:1fr}}
    .card{background:#fff;color:#111827;border-radius:14px;padding:16px;box-shadow:0 10px 25px rgba(0,0,0,.15)}
    .kpi{color:#fff;border-radius:14px;padding:16px;box-shadow:0 10px 25px rgba(0,0,0,.2);position:relative;overflow:hidden}
    .kpi small{opacity:.85}
    .kpi h3{margin:.35rem 0 0 0;font-size:1.75rem}
    .kpi--balance{background:linear-gradient(90deg,#10b981,#22c55e)}
    .kpi--income{background:linear-gradient(90deg,#2563eb,#6366f1)}
    .kpi--expense{background:linear-gradient(90deg,#f97316,#ef4444)}
    label{font-size:.85rem;color:#374151;margin-bottom:6px;display:block}
    input,select{width:100%;padding:10px;border:1px solid #e5e7eb;border-radius:10px}
    table{width:100%;border-collapse:collapse}
    th,td{padding:10px;border-bottom:1px solid #eee;text-align:left}
    th{text-transform:uppercase;font-size:.75rem;color:#111827}
    .right{text-align:right}
    .center{text-align:center}
    .badge{display:inline-block;padding:.25rem .5rem;border-radius:999px;background:rgba(16,185,129,.12);border:1px solid rgba(16,185,129,.35);color:#059669;font-weight:700;font-size:.75rem}
    footer{margin-top:18px;color:var(--muted);font-size:.85rem;text-align:center}
    .note{font-size:.9rem;color:#9ca3af}
    .action-group{display:flex;gap:4px;justify-content:flex-end;}

    /* Modal styles */
    .modal-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-color: rgba(0,0,0,0.6);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 100;
      transition: opacity 0.3s ease;
      opacity: 0;
      pointer-events: none;
    }
    .modal-overlay.open {
      opacity: 1;
      pointer-events: auto;
    }
    .modal-content {
      width: 90%;
      max-width: 400px;
      background-color: #fff;
      padding: 20px;
      border-radius: 14px;
      box-shadow: 0 10px 30px rgba(0,0,0,0.5);
      transform: translateY(-50px);
      transition: transform 0.3s ease;
    }
    .modal-overlay.open .modal-content {
      transform: translateY(0);
    }
    /* Estilo para el input en la tabla */
    .table-input {
      max-width: 120px; /* Ajustar el tamaño del input */
      padding: 4px;
      text-align: right;
      font-size: 0.9rem;
    }
  </style>

  <!-- React 18 + ReactDOM + Babel (para abrir directamente en el navegador). Requiere conexión a Internet. -->
  <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

  <!-- ✅ PWA configuration -->
  <link rel="manifest" href="manifest.json?v=5">
  <meta name="theme-color" content="#0f172a">
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <link rel="apple-touch-icon" href="icon-192.png">

  <!-- (opcional) Favicon -->
  <link rel="icon" href="icon-192.png" type="image/png">
</head>

<body>
  <div class="container">
    <header>
      <div>
        <h1>Control de Gastos</h1>
        <div class="note">Cada decisión financiera es una inversión en tu futuro.</div>
      </div>
      <div class="badge">Tu dinero, tus reglas.</div>
    </header>

    <div id="nav" class="nav"></div>
    <main id="app"></main>
    <footer>Pequeños hábitos, grandes finanzas.</footer>
  </div>

  <script type="text/babel">
    const { useState, useMemo, useEffect } = React;

    // Helpers
    const mxn = new Intl.NumberFormat('es-MX', { style: 'currency', currency: 'MXN', minimumFractionDigits: 2 });
    const uid = () => Math.random().toString(36).slice(2);

    // Persistencia simple
    const useLocalState = (key, initial) => {
      const [val, setVal] = useState(() => {
        try{ const raw = localStorage.getItem(key); return raw ? JSON.parse(raw) : initial; }catch{ return initial; }
      });
      useEffect(() => { localStorage.setItem(key, JSON.stringify(val)); }, [key, val]);
      return [val, setVal];
    };

    function App(){
      // Estados base (sin userId / sin Firebase)
      const [view, setView] = useState('dashboard'); // 'dashboard'|'fixed'|'cards'|'fuel'
      const [transactions, setTransactions] = useLocalState('txns', []);
      const [fixedExpenses, setFixedExpenses] = useLocalState('fixed', []);
      const [cards, setCards] = useLocalState('cards', []);
      const [fuel, setFuel] = useLocalState('fuel', []);
      const [settings, setSettings] = useLocalState('settings', { savingsGoal: 10 });
      // Mantener cardDebts para gestionar la deuda de TC
      const [cardDebts, setCardDebts] = useLocalState('cardDebts', []);


      // Helpers para duplicados por mes
      const monthKey = (d) => new Date(d).toISOString().slice(0,7); // YYYY-MM
      const isDuplicateTxn = (desc, amount) => {
        const todayKey = monthKey(new Date());
        // ✅ CORRECCIÓN: Usar la descripción original para la comparación, sin convertir a mayúsculas
        const U = String(desc||'');
        return transactions.some(t => (
          t.type==='expense' &&
          !t.cardId && // Solo verifica transacciones de débito/efectivo
          t.description===U &&
          monthKey(t.date)===todayKey &&
          // Compara la mensualidad si es MSI, o el monto total si no lo es.
          Number((t.msiMonths>1 ? t.amount/t.msiMonths : t.amount).toFixed(2))===Number(Number(amount).toFixed(2))
        ));
      };
      
      // FUNCIÓN AUXILIAR PARA AÑADIR DEUDA DE TC
      const addCardDebt = (txn) => {
        const id = uid();
        const monthlyAmount = txn.msiMonths > 1 ? txn.amount / txn.msiMonths : txn.amount;
        const totalMonths = txn.msiMonths > 1 ? txn.msiMonths : 1;

        const debt = {
          id: id,
          cardId: txn.cardId,
          date: txn.date,
          description: txn.description,
          originalAmount: txn.amount,
          remaining: txn.amount,
          monthlyAmount: monthlyAmount,
          totalMonths: totalMonths,
          msiMonths: totalMonths, // Mantener el nombre de la propiedad
          payments: [],
        };
        setCardDebts(prev => [debt, ...prev]);
      };
      
      // Agregar transacción (flujo de caja diario)
      const addTxn = (data) => {
        const t = {
          id: uid(),
          date: new Date().toISOString(),
          type: data.type, // 'income'|'expense'
          // ✅ CORRECCIÓN: Quitar .toUpperCase() para guardar el concepto tal cual
          description: String(data.description || ''),
          amount: Number(data.amount),
          cardId: data.cardId || null, // Guarda el ID de la tarjeta si se usó
          msiMonths: data.cardId ? Number(data.msiMonths || 1) : 1, // Guarda los MSI
          // ✅ NUEVA PROPIEDAD: Indica si la transacción fue generada desde la sección de Fijos
          isFixedSource: data.isFixedSource || false,
          // Propiedad para identificar si es un abono, para EXCLUIRLO de los cálculos de GASTOS totales.
          isPayment: data.isPayment || false 
        };

        // 1. Registrar al flujo de caja (Dashboard)
        setTransactions(prev => [t, ...prev]);

        // 2. Si es un GASTO con Tarjeta, registrar la deuda.
        if (t.type === 'expense' && t.cardId && !t.isPayment) {
            addCardDebt(t); 
        }

        // Opción: añadir a fijo si el usuario marcó (aplica a todos los gastos, ya sea efectivo o tarjeta)
        if(data.isFixedExpense && t.type==='expense' && !t.isPayment){
          // Si es MSI, el monto fijo es la mensualidad. Si es sin MSI o efectivo, es el monto total.
          const monthlyAmount = t.msiMonths > 1 ? t.amount / t.msiMonths : t.amount;
          addFixed(t.description, monthlyAmount);
        }
      };

      // Funciones de Tarjetas de Crédito / Deudas 
      // La función addCardDebt fue reubicada/implementada arriba.
      
      const delCardDebt = (id) => { setCardDebts(prevDebts => {
        const debtToDelete = prevDebts.find(d => d.id === id);
        if (debtToDelete) {
          // Si se elimina una deuda, también debemos eliminar la transacción original de gasto del Dashboard.
          setTransactions(prevTxns => prevTxns.filter(t => 
            // Elimina la transacción original de compra (no abono)
            !(t.cardId === debtToDelete.cardId && t.description === debtToDelete.description && t.amount === debtToDelete.originalAmount && !t.isPayment) &&
            // Elimina cualquier abono relacionado (aunque los abonos ya no afectan el total, es buena práctica)
            !(t.isPayment && String(t.description).includes(debtToDelete.description))
          ));
        }
        return prevDebts.filter(x => x.id !== id);
      }); };
      
      const makeCardPayment = (id, amount) => { 
        setCardDebts(prevDebts => prevDebts.map(debt => {
          if (debt.id === id) {
            const paymentAmount = Math.min(amount, debt.remaining);
            if (paymentAmount <= 0) return debt; 

            const newRemaining = debt.remaining - paymentAmount;
            
            // Añadir el abono como una transacción de gasto al Dashboard (flujo de caja)
            const cardName = cards.find(c=>c.id===debt.cardId)?.name || 'TARJETA';
            const paymentTxn = {
              id: uid(),
              date: new Date().toISOString(),
              type: 'expense',
              description: `ABONO: ${debt.description} (${cardName})`,
              amount: paymentAmount,
              cardId: null, 
              msiMonths: 1,
              isFixedSource: false,
              isPayment: true // ✅ CAMBIO CRÍTICO: Marca como abono para ser ignorado en cálculos
            };
            // Usamos addTxn para registrar el abono.
            addTxn(paymentTxn); // addTxn ahora maneja la lógica de guardado y marcado

            return {
              ...debt,
              remaining: newRemaining,
              payments: [...debt.payments, { date: new Date().toISOString(), amount: paymentAmount }]
            };
          }
          return debt;
        }));
      };

      // Añadir gasto fijo al Dashboard (uno o todos) como semanal, evitando duplicados del mes
      const addFixedTxn = (f) => {
        const weeklyAmount = Number(f.monthlyAmount || 0) / 4; // semanal
        const concept = f.concept;
        if(!concept || !weeklyAmount) return false;
        if(isDuplicateTxn(concept, weeklyAmount)) return false;
        // Se añade isFixedSource: true para identificar la transacción en el historial
        addTxn({ 
          type:'expense', 
          description: concept, 
          amount: weeklyAmount, 
          cardId: null, 
          msiMonths: 1, 
          isFixedExpense: false,
          isFixedSource: true,
          isPayment: false
        });
        return true;
      };
      const addAllFixedTxns = () => {
        let added = 0;
        fixedExpenses.forEach(f => { if(addFixedTxn(f)) added++; });
        // Se reemplaza alert() por un mensaje temporal si fuera necesario, pero por ahora se mantiene el alert
        if(window.confirm(added>0 ? `Se agregaron ${added} conceptos semanales al Dashboard.` : 'Nada por agregar: todos ya estaban registrados este mes.')){
          // No hace nada, solo es para confirmar el mensaje
        }
      };

      // Borrar transacción
      const delTxn = (id) => setTransactions(prev => prev.filter(x => x.id !== id));

      // Fijos
      const addFixed = (concept, monthlyAmount) => {
        // ✅ CORRECCIÓN: Quitar .toUpperCase() para guardar el concepto tal cual
        const f = { id: uid(), concept: String(concept||''), monthlyAmount: Number(monthlyAmount) };
        setFixedExpenses(prev => [f, ...prev]);
      };
      const delFixed = (id) => setFixedExpenses(prev => prev.filter(x => x.id !== id));

      // Tarjetas (Metadata)
      const addCard = (name, cutDay, paymentDay) => {
        // ✅ CORRECCIÓN: Quitar .toUpperCase() para guardar el nombre de la tarjeta tal cual
        const c = { id: uid(), name: String(name||''), cutDay: Number(cutDay), paymentDay: Number(paymentDay) };
        setCards(prev => [c, ...prev]);
      };
      const deleteCard = (id) => {
          if (cardDebts.some(d => d.cardId === id && d.remaining > 0)) {
              // Se reemplaza alert()
              if(window.confirm("No se puede eliminar la tarjeta. Existen deudas pendientes.")){}
              console.error("No se puede eliminar la tarjeta. Existen deudas pendientes.");
              return;
          }
          setCards(prev => prev.filter(c => c.id !== id));
      };


      // Combustible
      const addFuel = (r) => {
        const rec = { id: uid(), fecha: r.fecha, gasto: Number(r.gasto), litros: Number(r.litros), kmRecorridos: Number(r.kmRecorridos) };
        setFuel(prev => [rec, ...prev].sort((a,b)=> new Date(b.fecha)-new Date(a.fecha)));
      };
      const delFuel = (id) => setFuel(prev => prev.filter(x => x.id !== id));

      // Cálculos
      const { income, expenses, balance } = useMemo(() => {
        let inc=0, exp=0;
        
        transactions.forEach(t => {
          // 1. Ingresos siempre se suman
          if(t.type==='income') {
            inc += t.amount;
            return;
          }
          
          // 2. Si es un Gasto...
          if(t.type==='expense') {
            // ✅ CAMBIO CRÍTICO: IGNORAR ABONOS (isPayment: true) en la suma total de gastos
            if (t.isPayment) {
                // El abono solo se registra, no afecta el total de gastos/balance.
                return;
            }

            // Para GASTOS no-abono:
            // Si es MSI, sumar solo la mensualidad. Si no, sumar el monto completo.
            const flowAmount = t.msiMonths > 1 ? (t.amount / t.msiMonths) : t.amount;
            exp += flowAmount;
          } 
        });
        return { income: inc, expenses: exp, balance: inc-exp };
      }, [transactions]);

      const fixedAgg = useMemo(() => {
        const totalFixedMonthly = fixedExpenses.reduce((s,i)=> s + Number(i.monthlyAmount||0), 0);
        const fixedData = fixedExpenses.map(i => {
          const pct = totalFixedMonthly>0 ? (i.monthlyAmount/totalFixedMonthly)*100 : 0;
          return { ...i, percentage: pct.toFixed(2), weeklyProjected: i.monthlyAmount/4 };
        });
        const thirtyDaysAgo = new Date(Date.now()-30*24*60*60*1000);
        // Ahora el cálculo de variable usa TODAS las transacciones de gasto (EXCEPTO abonos)
        const variableLast30 = transactions
          // Filtra: solo gastos, no abonos, en los últimos 30 días
          .filter(t => t.type==='expense' && !t.isPayment && new Date(t.date)>=thirtyDaysAgo)
          // Sumar solo la mensualidad si es MSI
          .reduce((s,t)=> s + (t.msiMonths > 1 ? (t.amount / t.msiMonths) : t.amount), 0);
        const monthlyFlowProjection = totalFixedMonthly + variableLast30;
        return { fixedData, totalFixedMonthly, totalWeeklyProjected: totalFixedMonthly/4, monthlyFlowProjection, variableLast30 };
      }, [fixedExpenses, transactions]);

      // Calcula la deuda pendiente por tarjeta
      const cardDebt = (cardId) => {
        const tx = cardDebts.filter(d => d.cardId===cardId);
        const totalRemaining = tx.reduce((s,d)=> s + d.remaining, 0);
        return totalRemaining;
      };

      const fuelMetrics = useMemo(() => {
        const totalLitros = fuel.reduce((s,r)=> s + r.litros, 0);
        const totalGasto = fuel.reduce((s,r)=> s + r.gasto, 0);
        const totalKm = fuel.reduce((s,r)=> s + r.kmRecorridos, 0);
        const promedio = totalLitros>0 ? totalKm/totalLitros : 0;
        return { totalLitros, totalGasto, totalKm, promedio };
      }, [fuel]);

      return (
        <>
          <Nav current={view} onChange={setView} />
          {view==='dashboard' && <Dashboard
            income={income} expenses={expenses} balance={balance}
            transactions={transactions} cards={cards}
            onAdd={addTxn} onDelete={delTxn}
          />}
          {view==='fixed' && <FixedView
            data={fixedAgg} onAdd={addFixed} onDelete={delFixed}
            onPushAll={addAllFixedTxns} onPushOne={addFixedTxn}
          />}
          {view==='cards' && <CardsView
            cards={cards} onAdd={addCard} onDeleteCard={deleteCard}
            cardDebts={cardDebts} cardDebt={cardDebt}
            onDeleteDebt={delCardDebt} onPayment={makeCardPayment}
          />}
          {view==='fuel' && <FuelView records={fuel} metrics={fuelMetrics} onAdd={addFuel} onDelete={delFuel} />}
        </>
      );
    }

    function Nav({current,onChange}){
      const items=[
        {k:'dashboard',label:'Dashboard'},
        {k:'fixed',label:'Gastos Fijos'},
        {k:'cards',label:'Tarjetas'},
        {k:'fuel',label:'Combustible'},
      ];
      return (
        <div className="nav">
          {items.map(it => (
            <button key={it.k}
              className={"btn " + (current===it.k ? "btn--accent" : "btn--muted")}
              onClick={()=>onChange(it.k)}>{it.label}</button>
          ))}
          <button className="btn btn--ghost" onClick={()=>{
            // Se reemplaza alert() por console.log/confirm
            if(window.confirm("¿Borrar todos los datos guardados? (Transacciones, fijos, tarjetas y combustible)")){ localStorage.clear(); location.reload(); }
          }}>Reiniciar datos</button>
        </div>
      );
    }

    function Dashboard({income,expenses,balance,transactions,cards,onAdd,onDelete}){
      return (
        <div className="grid" style={{marginTop:16}}>
          <div className="grid grid--3">
            <div className="kpi kpi--balance"><small>Balance (Flujo de Caja)</small><h3>{mxn.format(balance)}</h3></div>
            <div className="kpi kpi--income"><small>Ingresos</small><h3>{mxn.format(income)}</h3></div>
            <div className="kpi kpi--expense"><small>Gastos Totales (Mensualidad)</small><h3>{mxn.format(expenses)}</h3></div>
          </div>

          <div className="grid" style={{gridTemplateColumns:'1fr 2fr'}}>
            <div className="card">
              <h3>Registrar Transacción</h3>
              <TxnForm cards={cards} onSubmit={onAdd} />
              {/* MENSAJE SIMPLIFICADO */}
              <p className="note" style={{marginTop:10}}>Todos los ingresos y gastos (efectivo, débito o tarjeta) se reflejan en este historial.</p>
            </div>
            <div className="card">
              <h3>Historial de Movimientos</h3>
              {transactions.length===0 ? <p className="note">Aún no hay transacciones.</p> : (
                <table>
                  <thead><tr><th>Fecha</th><th>Concepto</th><th className="right">Monto</th><th className="center">MSI</th><th></th></tr></thead>
                  <tbody>
                    {transactions.map(t => {
                      // El monto en el historial siempre debe ser la mensualidad para reflejar el flujo de caja
                      const monthly = t.msiMonths>1 ? t.amount/t.msiMonths : t.amount;
                      const cardName = cards.find(c=>c.id===t.cardId)?.name;
                      // Usa la nueva propiedad isPayment
                      const isAbono = t.isPayment; 
                      const isFixedSource = t.isFixedSource; 

                      let conceptDisplay;
                      if(isAbono) {
                          // ✅ Muestra el concepto de abono con estilo
                          conceptDisplay = <strong style={{color:'#6b21a8'}}>*ABONO* {t.description.substring(6)}</strong>;
                      } else {
                          // ✅ Usa t.description tal cual
                          conceptDisplay = <strong style={{color:t.type==='income'?'#059669':'#b91c1c'}}>{t.description}</strong>;
                      }
                      
                      return (
                        <tr key={t.id}>
                          <td>{new Date(t.date).toLocaleDateString('es-MX')}</td>
                          <td>
                            {conceptDisplay}
                            {isFixedSource && <span style={{marginLeft:6,color:'#0891b2',fontWeight:700}}>(Fijo)</span>}
                            {cardName && <span style={{marginLeft:6,color:'#1e40af',fontWeight:700}}>({cardName})</span>}
                            {!t.cardId && t.type==='expense' && !isAbono && !isFixedSource && <span style={{marginLeft:6,color:'#6b7280',fontWeight:500}}>(Efectivo/Débito)</span>}
                          </td>
                          <td className="right">{mxn.format(monthly)}{(t.msiMonths>1)? <div style={{fontSize:12,color:'#6b7280'}}>Total: {mxn.format(t.amount)}</div> : null}</td>
                          <td className="center">{t.msiMonths>1 ? t.msiMonths : '-'}</td>
                          <td className="right">
                            <button className="btn btn--danger" onClick={()=>onDelete(t.id)} title="Eliminar del flujo de caja">Eliminar</button>
                          </td>
                        </tr>
                      )
                    })}
                  </tbody>
                </table>
              )}
            </div>
          </div>
        </div>
      );
    }

    function TxnForm({cards,onSubmit}){
      const [type,setType]=React.useState('expense');
      const [description,setDescription]=React.useState('');
      const [amount,setAmount]=React.useState('');
      const [cardId,setCardId]=React.useState('');
      const [msiMonths,setMsiMonths]=React.useState(1);
      const [isFixed,setIsFixed]=React.useState(false);

      const submit=e=>{
        e.preventDefault();
        if(!description || !amount || Number(amount)<=0) return;
        // isFixedSource y isPayment son false por defecto para transacciones manuales
        onSubmit({
          type,
          description,
          amount,
          cardId:cardId||null,
          msiMonths:cardId?Number(msiMonths):1,
          isFixedExpense:isFixed && type==='expense',
          isFixedSource: false,
          isPayment: false // ✅ Transacción manual, no es un abono
        });
        setDescription(''); setAmount(''); setCardId(''); setMsiMonths(1); setIsFixed(false);
      };

      return (
        <form onSubmit={submit}>
          <div style={{display:'flex',gap:8,marginBottom:8}}>
            <button type="button" className={"btn "+(type==='income'?'btn--primary':'btn--muted')} onClick={()=>setType('income')}>Ingreso</button>
            <button type="button" className={"btn "+(type==='expense'?'btn--danger':'btn--muted')} onClick={()=>setType('expense')}>Gasto</button>
          </div>
          <label>Concepto</label>
          <input value={description} onChange={e=>setDescription(e.target.value)} placeholder="SUELDO / RENTA / GASOLINA" required />
          <div style={{display:'grid',gridTemplateColumns:'1fr 1fr',gap:8,marginTop:8}}>
            <div>
              <label>Monto (MXN)</label>
              <input type="number" value={amount} min="0.01" step="any" onChange={e=>setAmount(e.target.value)} required />
            </div>
            <div>
              <label>Método de Pago (Opcional)</label>
              <select value={cardId} onChange={e=>{ setCardId(e.target.value); if(!e.target.value) setMsiMonths(1); }}>
                <option value="">Efectivo/Débito</option>
                {cards.map(c => <option key={c.id} value={c.id}>{c.name} (Crédito)</option>)}
              </select>
            </div>
          </div>
          {cardId && (
            <div style={{marginTop:8}}>
              <label>MSI (meses)</label>
              <input type="number" value={msiMonths} min="1" step="1" onChange={e=>setMsiMonths(e.target.value)} />
            </div>
          )}
          {/* MOSTRAR SIEMPRE si es GASTO, independientemente del método de pago */}
          {type==='expense' && (
            <label style={{display:'flex',gap:8,alignItems:'center',marginTop:10}}>
              <input type="checkbox" checked={isFixed} onChange={e=>setIsFixed(e.target.checked)} />
              ¿Añadir a Gastos Fijos? (Se añadirá el monto mensual/msi)
            </label>
          )}
          <button className="btn btn--accent" type="submit" style={{marginTop:12,width:'100%'}}>Guardar</button>
        </form>
      );
    }

    function FixedView({data,onAdd,onDelete,onPushAll,onPushOne}){
      const [concept,setConcept]=React.useState('');
      const [amount,setAmount]=React.useState('');

      const submit=e=>{ e.preventDefault(); if(!concept || !amount) return; onAdd(concept,Number(amount)); setConcept(''); setAmount(''); };

      return (
        <div className="grid" style={{marginTop:16}}>
          <div className="grid grid--3">
            <div className="card">
              <small>Gasto Variable Estimado (30 días)</small>
              <h3>{mxn.format(data.variableLast30)}</h3>
            </div>
            <div className="card" style={{gridColumn:'span 2'}}>
              <small>Proyección de Flujo Mensual (Fijo + Variable)</small>
              <h3>{mxn.format(data.monthlyFlowProjection)}</h3>
              <div className="note">Base: {mxn.format(data.totalFixedMonthly)} (Fijo) + {mxn.format(data.variableLast30)} (Variable)</div>
            </div>
          </div>

          <div className="grid grid--3">
            <div className="card">
              <h3>Añadir Gasto Fijo</h3>
              <form onSubmit={submit}>
                <label>Concepto</label>
                <input value={concept} onChange={e=>setConcept(e.target.value)} placeholder="RENTA, NETFLIX" required />
                <label style={{marginTop:8}}>Monto mensual</label>
                <input type="number" value={amount} min="0.01" step="any" onChange={e=>setAmount(e.target.value)} required />
                <button className="btn btn--primary" type="submit" style={{marginTop:12,width:'100%'}}>Añadir</button>
              </form>
              <button className="btn btn--accent" style={{marginTop:12,width:'100%'}} onClick={onPushAll}>Enviar todo al Dashboard (semanal, sin duplicar)</button>
            </div>

            <div className="card" style={{gridColumn: 'span 2'}}>
              <h3>Proyección Semanal</h3>
              <p><strong>{mxn.format(data.totalWeeklyProjected)}</strong></p>
              <p className="note">Total fijo: {mxn.format(data.totalFixedMonthly)}</p>
            </div>
          </div>

          <div className="card">
            <h3>Desglose de Gastos Fijos</h3>
            {data.fixedData.length===0 ? <p className="note">Aún no hay fijos.</p> : (
              <table>
                <thead><tr><th>Concepto</th><th className="right">Mensual</th><th className="right">% del fijo</th><th className="right">Semanal</th><th className="center">Acción</th><th></th></tr></thead>
                <tbody>
                  {data.fixedData.map(i => (
                    <tr key={i.id}>
                      <td><strong>{i.concept}</strong></td>
                      <td className="right">{mxn.format(i.monthlyAmount)}</td>
                      <td className="right">{i.percentage}%</td>
                      <td className="right">{mxn.format(i.weeklyProjected)}</td>
                      <td className="center"><button className="btn btn--yellow" onClick={()=>onPushOne(i)}>Añadir al Dashboard</button></td>
                      <td className="right"><button className="btn btn--danger" onClick={()=>onDelete(i.id)}>Eliminar</button></td>
                    </tr>
                  ))}
                  <tr>
                    <td><strong>SUMA</strong></td>
                    <td className="right"><strong>{mxn.format(data.totalFixedMonthly)}</strong></td>
                    <td className="right">100%</td>
                    <td className="right"><strong>{mxn.format(data.totalWeeklyProjected)}</strong></td>
                    <td></td>
                    <td></td>
                  </tr>
                </tbody>
              </table>
            )}
          </div>
        </div>
      );
    }

    function CardsView({cards,onAdd,onDeleteCard,cardDebts,cardDebt,onDeleteDebt,onPayment}){
      const [name,setName]=React.useState('');
      const [cut,setCut]=React.useState('');
      const [pay,setPay]=React.useState('');
      // Estado para la cantidad a abonar que se pone en la tabla, mapeado por debtId
      const [tempPayments, setTempPayments] = React.useState({});
      // ✅ NUEVO ESTADO PARA EL FILTRO DE TARJETA
      const [selectedCardId, setSelectedCardId] = React.useState(''); // ID de la tarjeta para filtrar
      
      const [showPaymentModal, setShowPaymentModal] = React.useState(false);
      const [currentDebt, setCurrentDebt] = React.useState(null);
      const [paymentAmount, setPaymentAmount] = React.useState(''); // Usado por el modal
      

      const submit=e=>{ e.preventDefault(); if(!name||!cut||!pay) return; onAdd(name,cut,pay); setName(''); setCut(''); setPay(''); };

      // Actualizar el estado temporal de pago cuando el usuario escribe en el input de la tabla
      const handleTempPaymentChange = (debtId, value) => {
        const numValue = Number(value);
        if (isNaN(numValue) || numValue < 0) return;
        setTempPayments(prev => ({
          ...prev,
          [debtId]: numValue
        }));
      };

      const openPaymentModal = (debt, prefilledAmount = 0) => {
        setCurrentDebt(debt);
        // Usar el monto prellenado (el que se tecleó en el input de la tabla)
        setPaymentAmount(Math.min(prefilledAmount, debt.remaining).toFixed(2));
        setShowPaymentModal(true);
      };

      const handlePaymentSubmit = (e) => {
        e.preventDefault();
        const amount = Number(paymentAmount);
        if (currentDebt && amount > 0) {
          onPayment(currentDebt.id, amount);
          setShowPaymentModal(false);
          setCurrentDebt(null);
          setPaymentAmount('');
          // Limpiar el estado temporal después de registrar el pago
          setTempPayments(prev => {
              const newPayments = {...prev};
              delete newPayments[currentDebt.id];
              return newPayments;
          });
        }
      };

      // ✅ DATOS FILTRADOS
      const filteredDebts = useMemo(() => {
          if (!selectedCardId) {
              return cardDebts;
          }
          return cardDebts.filter(d => d.cardId === selectedCardId);
      }, [cardDebts, selectedCardId]);


      const PaymentModal = () => {
        if (!showPaymentModal || !currentDebt) return null;

        return (
          <div className={`modal-overlay ${showPaymentModal ? 'open' : ''}`}>
            <div className="modal-content">
              <h3>Abono a {currentDebt.description}</h3>
              <p className="note">Monto original: {mxn.format(currentDebt.originalAmount)}</p>
              <p className="note" style={{marginBottom:10}}>Saldo restante: <strong style={{color: '#b91c1c'}}>{mxn.format(currentDebt.remaining)}</strong></p>
              
              <form onSubmit={handlePaymentSubmit}>
                <label>Monto a Abonar (MXN)</label>
                <input
                  type="number"
                  value={paymentAmount}
                  min="0.01"
                  max={currentDebt.remaining}
                  step="any"
                  onChange={e => setPaymentAmount(e.target.value)}
                  required
                />
                <div style={{display:'flex', gap:8, marginTop:15}}>
                  <button type="button" className="btn btn--muted" onClick={() => setShowPaymentModal(false)} style={{flexGrow:1}}>Cancelar</button>
                  <button type="submit" className="btn btn--accent" style={{flexGrow:1}} disabled={Number(paymentAmount) <= 0 || Number(paymentAmount) > currentDebt.remaining}>Registrar Abono</button>
                </div>
              </form>
            </div>
          </div>
        );
      };


      return (
        <div className="grid" style={{marginTop:16}}>
          <PaymentModal />
          <div className="grid" style={{gridTemplateColumns:'1fr 2fr',gap:16}}>
            <div className="card">
              <h3>Añadir Tarjeta (Crédito)</h3>
              <form onSubmit={submit}>
                <label>Nombre</label><input value={name} onChange={e=>setName(e.target.value)} required />
                <div style={{display:'grid',gridTemplateColumns:'1fr 1fr',gap:8,marginTop:8}}>
                  {/* Se añade step="1" para asegurar la entrada de enteros */}
                  <div><label>Día de corte</label><input type="number" value={cut} min="1" max="31" step="1" onChange={e=>setCut(e.target.value)} required /></div>
                  {/* Se añade step="1" para asegurar la entrada de enteros */}
                  <div><label>Día de pago</label><input type="number" value={pay} min="1" max="31" step="1" onChange={e=>setPay(e.target.value)} required /></div>
                </div>
                <button className="btn btn--yellow" type="submit" style={{marginTop:12,width:'100%'}}>Registrar</button>
              </form>
            </div>
            <div className="card">
              <h3>Deuda Total por Tarjeta</h3>
              {cards.length===0 ? <p className="note">Aún no hay tarjetas.</p> : (
                <table>
                  <thead><tr><th>Tarjeta</th><th>Corte</th><th>Pago</th><th className="right">Deuda Pendiente</th><th></th></tr></thead>
                  <tbody>
                    {cards.map(c => (
                      <tr key={c.id}>
                        <td><strong>{c.name}</strong></td>
                        <td>{c.cutDay}</td>
                        <td>{c.paymentDay}</td>
                        <td className="right" style={{color: cardDebt(c.id) > 0 ? '#b91c1c' : '#059669'}}>
                          {mxn.format(cardDebt(c.id))}
                        </td>
                        <td className="right">
                           <button className="btn btn--danger" onClick={() => onDeleteCard(c.id)} title="Eliminar tarjeta">X</button>
                        </td>
                      </tr>
                    ))}
                  </tbody>
                </table>
              )}
              <p className="note" style={{marginTop:8}}>Esta sección muestra el saldo pendiente de las compras realizadas a crédito.</p>
            </div>
          </div>
          <div className="card">
            <div style={{display:'flex', justifyContent:'space-between', alignItems:'center', marginBottom:12}}>
              <h3>Movimientos de Tarjeta (Deuda Pendiente)</h3>
              {/* ✅ NUEVO FILTRO */}
              <div style={{width:'300px'}}>
                <label>Filtrar por Tarjeta</label>
                <select value={selectedCardId} onChange={e => setSelectedCardId(e.target.value)}>
                  <option value="">TODAS las tarjetas</option>
                  {cards.map(c => <option key={c.id} value={c.id}>{c.name}</option>)}
                </select>
              </div>
              {/* FIN NUEVO FILTRO */}
            </div>
            
            {/* Usar los datos filtrados: filteredDebts */}
            {filteredDebts.length===0 ? <p className="note">Sin movimientos de deuda con tarjeta{(selectedCardId && cardDebts.length > 0) ? ` para la tarjeta seleccionada.` : '.'}</p> : (
              <table>
                <thead>
                  <tr>
                    <th>Fecha Compra</th>
                    <th>Tarjeta</th>
                    <th>Concepto</th>
                    <th className="right">Monto Original</th>
                    <th className="center">MSI</th>
                    <th className="right">Saldo Pendiente</th>
                    {/* ✅ NUEVAS COLUMNAS */}
                    <th className="right">Cant. a Abonar</th>
                    <th className="right">Faltante</th>
                    {/* FIN NUEVAS COLUMNAS */}
                    <th className="right">Acciones</th>
                  </tr>
                </thead>
                <tbody>
                  {filteredDebts.map(d => {
                    const cardName = cards.find(c=>c.id===d.cardId)?.name || '—';
                    const isPaid = d.remaining <= 0;
                    
                    // Obtener el monto temporal o 0
                    const tempAmount = tempPayments[d.id] || 0;
                    // Calcular el faltante
                    const faltante = isPaid ? 0 : Math.max(0, d.remaining - tempAmount);

                    return (
                      <tr key={d.id}>
                        <td>{new Date(d.date).toLocaleDateString('es-MX')}</td>
                        <td>{cardName}</td>
                        {/* ✅ CORRECCIÓN: Usar d.description tal cual */}
                        <td>{d.description}</td>
                        <td className="right">{mxn.format(d.originalAmount)}</td>
                        <td className="center">{d.msiMonths>1 ? d.msiMonths : '-'}</td>
                        <td className="right" style={{color: isPaid ? '#059669' : '#b91c1c', fontWeight: 700}}>
                          {mxn.format(d.remaining)}
                          {isPaid && <div style={{fontSize:12, fontWeight:400}}>PAGADA</div>}
                        </td>
                        
                        {/* ✅ NUEVA COLUMNA: Cantidad a Abonar (Input) */}
                        <td className="right">
                          <input 
                            type="number"
                            className="table-input"
                            value={isPaid ? '' : tempAmount}
                            onChange={(e) => handleTempPaymentChange(d.id, e.target.value)}
                            min="0"
                            // Limitar la cantidad máxima a lo que resta por pagar
                            max={d.remaining.toFixed(2)}
                            step="any"
                            disabled={isPaid}
                            placeholder="0.00"
                          />
                        </td>
                        
                        {/* ✅ NUEVA COLUMNA: Faltante */}
                        <td className="right" style={{color: faltante===0 ? '#059669' : '#b91c1c', fontWeight: 700}}>
                            {mxn.format(faltante)}
                        </td>

                        <td className="right">
                          <div className="action-group">
                            {/* Botón de Abonar usa el monto tecleado en la tabla como prellenado */}
                            <button 
                              className="btn btn--accent" 
                              disabled={isPaid || tempAmount <= 0 || tempAmount > d.remaining} 
                              onClick={() => openPaymentModal(d, tempAmount)} 
                              title="Registrar un abono"
                            >
                              Abonar
                            </button>
                            <button className="btn btn--danger" onClick={() => onDeleteDebt(d.id)} title="Eliminar la compra de la lista de deuda">Eliminar</button>
                          </div>
                        </td>
                      </tr>
                    );
                  })}
                </tbody>
              </table>
            )}
          </div>
        </div>
      );
    }

    function FuelView({records,metrics,onAdd,onDelete}){
      const today = new Date().toISOString().split('T')[0];
      const [fecha,setFecha]=React.useState(today);
      const [gasto,setGasto]=React.useState('');
      const [litros,setLitros]=React.useState('');
      const [km,setKm]=React.useState('');

      const submit=e=>{
        e.preventDefault();
        if(!fecha||!gasto||!litros||!km) return;
        onAdd({fecha,gasto,litros,kmRecorridos:km});
        setGasto(''); setLitros(''); setKm('');
      };

      const calcRow = (r, prevDate) => {
        const rendimiento = r.kmRecorridos / r.litros;
        const costo = r.gasto / r.litros;
        const dayDiff = prevDate ? Math.ceil(Math.abs((new Date(r.fecha)-new Date(prevDate))/(1000*60*60*24))) : null;
        return { rendimiento: rendimiento.toFixed(2), costo, dayDiff };
      };

      return (
        <div className="grid" style={{marginTop:16}}>
          <div className="grid" style={{gridTemplateColumns:'1fr 2fr',gap:16}}>
            <div className="card">
              <h3>Registro de Carga</h3>
              <form onSubmit={submit}>
                <label>Fecha</label><input type="date" value={fecha} max={today} onChange={e=>setFecha(e.target.value)} required/>
                <div style={{display:'grid',gridTemplateColumns:'1fr 1fr',gap:8,marginTop:8}}>
                  <div><label>Gasto ($)</label>
                    {/* Se usa step="any" para aceptar enteros y decimales */}
                    <input type="number" min="0.01" step="any" value={gasto} onChange={e=>setGasto(e.target.value)} required/>
                  </div>
                  <div><label>Litros (L)</label>
                    {/* Se usa step="any" para aceptar enteros y decimales */}
                    <input type="number" min="0.01" step="any" value={litros} onChange={e=>setLitros(e.target.value)} required/>
                  </div>
                </div>
                <label style={{marginTop:8}}>Km desde última carga</label>
                {/* Se usa step="any" para aceptar enteros y decimales */}
                <input type="number" min="1" step="any" value={km} onChange={e=>setKm(e.target.value)} required/>
                <button className="btn btn--primary" type="submit" style={{marginTop:12,width:'100%'}}>Registrar</button>
              </form>
            </div>
            {/* INICIO: Bloque de Métricas modificado */}
            <div className="card">
              <h3>Métricas Consolidadas</h3>
              <div className="grid grid--3">
                <div className="card"><small>Cargas Totales</small><h3>{records.length}</h3></div>
                <div className="card"><small>Gasto Total</small><h3>{mxn.format(metrics.totalGasto)}</h3></div>
                <div className="card"><small>Km Totales</small><h3>{metrics.totalKm.toFixed(1)} Km</h3></div>
                
                <div className="card"><small>Rendimiento Promedio</small><h3>{metrics.promedio.toFixed(2)} Km/L</h3></div>
                <div className="card"><small>Costo Promedio/L</small><h3>{mxn.format(metrics.totalLitros>0 ? metrics.totalGasto/metrics.totalLitros : 0)}</h3></div>
                <div className="card"><small>Litros Totales</small><h3>{metrics.totalLitros.toFixed(2)} L</h3></div>
              </div>
              <p className="note" style={{marginTop:12}}>Resumen histórico de tus registros de combustible.</p>
            </div>
            {/* FIN: Bloque de Métricas modificado */}
          </div>

          <div className="card">
            <h3>Historial de Cargas</h3>
{records.length === 0 ? (
  <p className="note">Sin registros.</p>
) : (
  <table>
    <thead>
      <tr>
        <th>Fecha</th>
        <th className="right">Gasto</th>
        <th className="right">Litros</th>
        <th className="right">Km</th>
        <th className="center">Km/L</th>
        <th className="right">$/L</th>
        <th className="center">D / RINDIO</th>
        <th></th>
      </tr>
    </thead>
    <tbody>
      {records.map((r, i) => {
        const prev = records[i + 1];
        const { rendimiento, costo, dayDiff } = calcRow(r, prev?.fecha);

        // Función para mostrar fecha sin zona horaria
        const fmtFecha = (str) => {
          const [y, m, d] = str.split('-').map(Number);
          const meses = [
            'ene','feb','mar','abr','may','jun','jul','ago','sep','oct','nov','dic'
          ];
          return `${String(d).padStart(2, '0')} ${meses[m - 1]} ${String(y).slice(-2)}`;
        };

        return (
          <tr key={r.id}>
            <td>{fmtFecha(r.fecha)}</td>
            <td className="right">{mxn.format(r.gasto)}</td>
            <td className="right">{r.litros.toFixed(2)} L</td>
            <td className="right">{r.kmRecorridos.toFixed(1)} Km</td>
            <td className="center">{rendimiento}</td>
            <td className="right">{mxn.format(costo)}</td>
            <td className="center">{dayDiff ?? '—'}</td>
            <td className="right">
              <button className="btn btn--danger" onClick={() => onDelete(r.id)}>
                Eliminar
              </button>
            </td>
          </tr>
        );
      })}
    </tbody>
  </table>
)}
</div>
</div>
);
}

    // Render
    const root = ReactDOM.createRoot(document.getElementById('app'));
    root.render(<App/>);
  </script>

  <script>
    if ('serviceWorker' in navigator) {
    window.addEventListener('load', () => {
      navigator.serviceWorker
        .register('sw.js')
        .then(() => console.log('SW registrado correctamente'))
        .catch(err => console.log('Error al registrar SW', err));
    });
  }
  </script>

</body>
</html>
